#pragma config(Sensor, in1,    potentiometer,  sensorPotentiometer)
#pragma config(Sensor, in2,    light,          sensorReflection)
#pragma config(Sensor, in3,    lineFollower,   sensorLineFollower)
#pragma config(Sensor, dgtl1,  sonar,          sensorSONAR_inch)
#pragma config(Sensor, dgtl3,  encoder,        sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  bump,           sensorTouch)
#pragma config(Sensor, dgtl6,  limit,          sensorTouch)
#pragma config(Sensor, dgtl11, led,            sensorLEDtoVCC)
#pragma config(Motor,  port1,           flashlight,    tmotorVexFlashlight, openLoop, reversed)
#pragma config(Motor,  port2,           rMotor,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           servo,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port10,          lMotor,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* Ben Godfrey    *
 * POE 8th Period *
 * Activity 3.1.7 *
 * 03/23/2017     */

// Constant Variables
const bool ENABLE_SAFEGUARD = false;
const bool SONAR_CHECK  = false;
const int  MAX_THROTTLE = 4095;
const int  SENSETIVITY  = 10;
const int  BUMP_MOD     = 10;
const int  MAX          = 127;

// Initialize Global Variables
int throttle = SensorValue[potentiometer];
int modifier = 0;

// Flags for previous switch state
bool limitState = false;
bool bumpState  = false;

int getSpeed() {
	return (ceil((throttle * MAX) / MAX_THROTTLE) + (modifier * BUMP_MOD));
	// speed equals throttle proportional to motor max speed,
	//   plus the modifier times modifier change factor.
}

// Checks for throttle changes and adjusts accordingly.
void checkThrottle(int &throttle, int &modifier) {
	if (abs(throttle - SensorValue[potentiometer]) > SENSETIVITY) { // if throttle changes more than tolerance
		throttle = SensorValue[potentiometer]; // reset throttle value
		modifier = 0;                          // reset modifier
	}
}

// Checks modifier switches and adjusts accordingly.
void checkMod(int &modifier) {
	if (!bumpState && SensorValue[bump] == 1) {     // if bump switch pressed, but wasn't previously
		if (getSpeed() + BUMP_MOD < MAX + BUMP_MOD || !ENABLE_SAFEGUARD) {
			// if change doesn't make motor greater than threshold
			modifier++; // increment modifier
		}
		bumpState = true; // flag button as previously pressed
	} else if (bumpState && SensorValue[bump] == 0) { // if button released
		bumpState = false; // flag button as not previously pressed
	}

	if (!limitState && SensorValue[limit] == 1) { // if limit switch pressed, but wasn't previously
		if (getSpeed() - BUMP_MOD > -BUMP_MOD || !ENABLE_SAFEGUARD) {
			// if change doesn't make motor less than threshold
			modifier--; // decrement modifier
		}
		limitState = true; // flag switch as previously pressed
	} else if (limitState && SensorValue[limit] == 0) { // if switch released
	  limitState = false; // flag switch as not previously pressed
	}
}


// Sets motors to correct speed based on throttle & modifier.
void setMotors(int throttle, int modifier) {

	int speed = getSpeed(); // get speed, store it temporarily

	if (speed < 0) { // if the speed is less than zero,
		speed = 0;     // set speed to zero
	} else if (speed > MAX) { // if speed greater than max
	  speed = MAX;             // set speed to max
	}

	motor[lMotor] = speed; // set both motors to the speed
	motor[rMotor] = speed;

}

void halt() {
	setMotors(0,0); // set speed on all motors to zero.
}

task main() {
	while (true) {
		if (!SONAR_CHECK || SensorValue[sonar] > 5) {
			checkMod(modifier);
			checkThrottle(throttle, modifier);
			setMotors(throttle, modifier);
		} else {
			halt();
		}
	}
}
